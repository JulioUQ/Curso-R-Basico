---
title: "![](uoc_logo.jpeg){width=4in}\n\nExploración y preprocesamiento de datos"
author: "Julio Úbeda Quesada"
date: "Análisis Estadístico - `r format(Sys.time(), '%d/%m/%Y, %H:%M')`"
abstract: |
 Este documento presenta la primera actividad del curso de Análisis Estadístico (Semestre 2024.2), enfocada en la exploración y preprocesamiento de datos. Se trabaja con un conjunto de datos sobre salud del sueño y estilo de vida, el cual contiene variables relacionadas con hábitos de sueño, actividad física, niveles de estrés y otros factores de salud. La actividad se estructura en varias etapas clave: carga y preparación de los datos, normalización de variables categóricas, identificación y corrección de inconsistencias en variables cuantitativas, detección y tratamiento de valores erróneos o atípicos, imputación de valores faltantes mediante el método de los k vecinos más cercanos, cálculo e interpretación de correlaciones, y análisis descriptivo y visual. Finalmente, se genera un archivo de datos procesados listo para su análisis posterior. La actividad enfatiza la precisión en el uso de la terminología estadística, la concisión en la presentación de los resultados y la optimización del código en R para el tratamiento de los datos.
 
output:
  html_document:
    toc: true
---

<!-- INITIALIZATION -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  eval = TRUE,
  message = FALSE,
  warning = FALSE,
  error = FALSE
)
```

<!-- LIBRERIAS -->

```{r load_libraries, include=FALSE, results='hide'}
rm(list=ls())

#--------------ESPACIO DE TRABAJO Y RUTAS RELATIVAS---------------#
# Modificar por el path del directorio de trabajo 
home_file  = "C:/Users/jubeda2/Desktop/Analisis Estadistico - Aula 3/Actividad 1 - Preprocesado de datos"
data_loc   = paste0(home_file,"/1. Datos/")
fig_loc    = paste0(home_file,"/6. Figuras_y_graficos/")
Output_loc = paste0(home_file, "/2. Enunciados y Solucion/")

#--------------PAQUETES NECESARIOS PARA EL CURSO---------------#
Packages = c("tidyverse", "readxl", "gridExtra", "ggplot2", "ggcorrplot", "kableExtra", "knitr", "VIM", "reshape2", 'corrplot')

# Instalar los paquetes que no estén instalados
new_packages <- Packages[!(Packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)

# Cargar los paquetes
lapply(Packages, library, character.only = TRUE)
```

\newpage

# **1.Preparación del conjunto de datos**
## **1.1. Cargar el archivo de datos**

En esta subsección, se procesa un archivo Excel (.xlsx) con datos sobre salud del sueño y estilo de vida, utilizando R para cargar y mostrar una muestra del conjunto.

```{r, Input}
# 1. Definimos la ruta del archivo de datos
file_path <- paste0(data_loc, "sleephealth.xlsx")

# 2. Leemos los datos desde el archivo Excel
uoc_df <- read_excel(file_path)

# 3. Mostramos la estructura del dataset
cat("La estructura del conjunto de datos de salud del sueño y estilo de vida es:\n\n")
str(uoc_df)
```
 
Tras cargar los datos en R, se verifica su correcta transmisión. El dataframe resultante, con 374 filas y 13 columnas, coincide exactamente con el archivo Excel, confirmando su estructura.


## **1.2. Identificación de valores duplicados**

El conjunto de datos debe tener un registro por `ID`, por lo que cualquier duplicado indica un error en la captura. Para identificar registros duplicados, filtramos los `ID` con más de un registro asociado de la siguiente manera:

```{r, Duplicates_checking}
# 1. Detectamos duplicados exactos por el identificador 'ID'
duplicates_by_id <- uoc_df %>%
  group_by(Person.ID) %>%
  filter(n() > 1) %>%
  ungroup()

# 2. Mostrar los duplicados 
duplicates_by_id %>% 
          kable(caption = "Registros con el mismo ID:", "html") %>% 
          kable_styling(font_size = 12, full_width = TRUE)
```
 
La presencia de registros con el mismo `Person.ID` indica duplicados, tanto exactos como parciales, posiblemente por errores en la captura o consolidación de datos. Si provienen de múltiples fuentes, podrían existir inconsistencias al unirlos. Para evitar perder información, creamos una nueva columna `New.Person.ID` con valores únicos y secuenciales.

```{r, ID_Correction}
# 1. Creamos un ID único autoincremental
uoc_df <- uoc_df %>%
  mutate(New.Person.ID = row_number())  

# 2. Comprobamos que es único por registro
duplicates_by_id <- uoc_df %>%
  group_by(New.Person.ID) %>%
  filter(n() > 1) %>%
  ungroup()

# Mostrar los duplicados si los hay 
duplicates_by_id %>% 
          kable(caption = "Registros con el mismo ID:", "html") %>% 
          kable_styling(font_size = 12, full_width = TRUE)
```

## **1.3. Identificación de valores vacíos y/o nulos**

Antes de iniciar el análisis, es crucial verificar cómo R ha interpretado los valores ausentes. Para ello, revisamos la presencia de valores nulos (`NA`), espacios en blanco o cadenas vacías en todas las columnas del dataframe.

```{r, Empty_null_values_checking}
# 1. Identificamos columnas con valores vacíos (NA o "") 
columnas_con_vacios <- sapply(uoc_df, function(x) any(is.na(x) | x == "" | x == " "))  

# 2. Mostramos las columnas que tienen valores vacíos 
columnas_vacias <- names(uoc_df)[columnas_con_vacios] 
cat("Las columnas con valores vacíos son: ", columnas_vacias, "\n")
```

En este caso, la variable `Age` es la única con valores nulos (`NA`). No se han encontrado registros vacíos adicionales. En los siguientes apartados, estos valores serán imputados según el método especificado.


## **1.4. Simplificación del nombre de las columnas**

Finalmente, renombramos las columnas para simplificar el código y mejorar la legibilidad:

`New.Person.ID` → `ID`  
`Sleep.Duration` → `SH`  
`Quality.of.Sleep` → `SQ`  
`Physical.Activity.Level` → `PHY`  
`Stress.Level` → `Stress`  
`BMI.Category` → `BMI`  
`Blood.Pressure` → `BP`  
`Heart.Rate` → `HR`  
`Daily.Steps` → `Steps`  
`Sleep.Disorder` → `SD`

El código en R para este proceso es:

 
```{r, Renaming}
uoc_df <- uoc_df %>%
  rename(
    ID = New.Person.ID, # Utilizamos el ID sin incosistencias en los datos
    SH = Sleep.Duration,
    SQ = Quality.of.Sleep,
    PHY = Physical.Activity.Level,
    Stress = Stress.Level,
    BMI = BMI.Category,
    BP = Blood.Pressure,
    HR = Heart.Rate,
    Steps = Daily.Steps,
    SD = Sleep.Disorder
  )

# Verificamos
head(uoc_df, 5) %>% 
          kable(caption = "Dataset con columnas renombradas:", "html") %>% 
          kable_styling(font_size = 12, full_width = TRUE)
```

\newpage

# **2. Normalización de formatos en variables categóricas**

Comenzamos el análisis explorando las variables que R ha identificado como categóricas en nuestro conjunto de datos.

 
```{r, VarCategoricas}
# 1. Filtramos las columnas categóricas
df_categoricas <- uoc_df %>%
  select(where(~ is.character(.x) | is.factor(.x)))

# 2. Mostramos las columnas categoricas
cat("Las variables categóricas son: ", names(df_categoricas), "\n")
```
 

## **2.1. Errores sintácticos**

Existen caracteres que pueden importarse junto a los datos y causar problemas en el análisis, como espacios en blanco antes o después del texto, o caracteres especiales como el retorno de carro o tabulación. Comenzamos eliminando estos caracteres con el siguiente código:

 
```{r, SintaxErrors_Checking}
# 1. Filtramos las columnas que tienen al menos un valor con espacios al inicio o final
df_categoricas[, apply(df_categoricas, 2, function(col) any(grepl("^\\s|\\s$", col)))]
```
 

**No hay espacios en blanco al inicio o al final en ninguna de las columnas categóricas.**

## **2.2. Errores deduciendo el tipo de dato**

Cuando R carga el conjunto de datos, asigna automáticamente tipos a cada variable según sus valores. Sin embargo, en algunos casos, estas asignaciones pueden ser incorrectas. A continuación, corregimos dos variables clave:

-   **Age:** Aunque representa una cantidad numérica entera, fue clasificada como `character`. Convertimos esta variable a `integer`.

 

```{r, Norm_cat_Age}
# 1. Convertimos a tipo numérico 
uoc_df <- uoc_df %>%
  mutate(Age = as.integer(Age))

# 2. Verificamos los cambios
cat("Tipo de 'Age':", class(uoc_df$Age), "\n")
```

-   **SH (Sleep Hours)**: Fue interpretada como `character` debido a inconsistencias en el separador decimal ("," y "."). Reemplazamos "," por "." y convertimos a `numeric`.

 

```{r, Norm_cat_SH}
# 1. Reemplazamos la `,` por el `.`y transformamos a numerico la variable SH
uoc_df <- uoc_df %>%
  mutate(SH = as.numeric(gsub(",", ".", SH)))

# 2. Verificamos los cambios
cat("Tipo de 'SH':", class(uoc_df$SH), "\n")
```
 

## **2.3. Estandarización de las categorias**

Algunas variables categóricas presentan inconsistencias en su formato y nomenclatura. Aplicamos las siguientes correcciones para unificar los valores:

-   **Occupation:** Unificamos las ocupaciones similares como '`Engineer`', '`engineer`' y '`Sofware Engineer`' bajo un único término '`Engineer`'. Igualmente con las ocupaciones '`Sales Representative`' y '`Salesperson`' pasan a ser '`Salesperson`'.

 

```{r, Norm_cat_Occupation}
# 1. Estandarizar capitalización
uoc_df$Occupation <- str_to_title(uoc_df$Occupation)

# 2. Unificamos nombres de ocupaciones 
uoc_df$Occupation <- recode(uoc_df$Occupation,
                            "Software Engineer" = "Engineer",
                            "Sales Representative" = "Salesperson",
                            .default = uoc_df$Occupation)  

# 3. Verificamos los cambios
cat("Valores únicos de 'Occupation' después de la corrección:\n", unique(uoc_df$Occupation), "\n")
```

 

-   **BMI:** Unificamos '`Normal Weight`' en '`Normal`'.

 

```{r, Norm_cat_BMI}
# 1. # Unificamos BMI (convertir "Normal Weight" a "Normal")
uoc_df <- uoc_df %>%
  mutate(BMI = ifelse(BMI == "Normal Weight", "Normal", BMI))

# 2. Verificamos los cambios
cat("Valores únicos de 'BMI' después de la corrección:\n", unique(uoc_df$BMI), "\n")
```
 

Las variables `BP (presión arterial)` y `SD (trastornos del sueño)` no presentan inconsistencias:
- **BP** mantiene el formato correcto (XXX/XX).
- **SD** contiene valores válidos (Sleep Apnea, Insomnia, None).

\newpage

# **3 Inconsistencias en variables cuantitativas**
## **3.1. Identificación de variables cuantitativas**

Seleccionamos las variables cuantitativas del dataset:

 
```{r, VarCuantitativas}
# 1. Filtramos las variables cuantitativas (numéricas)
df_cuantitativas <- uoc_df %>%
  select(where(is.numeric))

# 2. Mostramos las columnas cuantitativas
cat("Las variables cuantitativas son: ", names(df_cuantitativas), "\n")
```
  

## **3.2. Revisión de valores vacios**

Revisamos y reemplazamos los registros vacíos por `NA` con el siguiente código:

 
```{r}
# 1. Recorremos cada columna y reemplazamos los espacios en blanco por NA
uoc_df[] <- lapply(uoc_df, function(x) {
  x[x == ""] <- NA
  return(x)
})

# 2. Mostramos las columnas que contienen NA
columnas_con_na <- sapply(uoc_df, function(x) any(is.na(x)))
cat("Columnas que contienen NA:\n", paste(names(uoc_df)[columnas_con_na], collapse = ", "))
```
  

Como se mencionó en el primer apartado, solo la columna `AGE` contiene valores desconocidos o perdidos, y ya han sido transformados a `NA`. Aún así, aseguramos la transformación en el código anterior.

## **3.3. Descomposición de la columna BP en dos: BPsyst y BPdias**

En este apartado, se crean dos columnas numéricas: una para la presión sistólica (`BPsyst`) y otra para la diastólica (`BPdias`), extrayendo los valores del numerador y denominador de la columna `BP`.

 
```{r, Descomp_BP}
# 1. Descomponemos la columna BP en dos: Systolic_BP y Diastolic_BP
uoc_df$BPsyst <- as.numeric(sapply(strsplit(uoc_df$BP, "/"), function(x) x[1]))
uoc_df$BPdias <- as.numeric(sapply(strsplit(uoc_df$BP, "/"), function(x) x[2]))

# Verificamos
head(uoc_df, 5) %>% 
          kable(caption = "Dataset descomponiendo BP en BPsyst y BPdias:", "html") %>% 
          kable_styling(font_size = 12, full_width = TRUE)
```
\newpage

# **4 Valores erróneos o atípicos**

En este apartado, se revisan los valores de las variables numéricas. Primero, se sustituyen los **valores erróneos** por `NAs`. Luego, se identifican los valores atípicos y, si es necesario, se reemplazan por `NAs`, justificando la decisión. Estos análisis se realizan en dos subapartados separados, y en el siguiente se imputarán los `NAs`.

## **4.1 Valores erróneos**

En este apartado podrían incluirse los valores inconsistentes que se encontraron en el primer apartado en relación a la columna `Person.ID` (ver Apartado 1.2).

## **4.2 Valores atípicos**

En R, podemos identificar los valores atípicos usando el criterio del rango intercuartílico (IQR) en ggplot con la sentencia [outlier.color](https://www.geeksforgeeks.org/coloring-boxplot-outlier-points-in-ggplot2/). Esta identifica outliers como valores por debajo de Q1 - 1.5 * IQR o por encima de Q3 + 1.5 * IQR. A continuación, se muestra el gráfico Boxplot centrado en los valores atípicos y posibles errores en los datos:

 
```{r, Boxplots, fig.height=6, fig.width=9}
# 1. Definimos la ruta para guardar el gráfico
figura_guardada <- paste0(fig_loc, "/Boxplot de las variables.png")

# 2. Seleccionamos solo las columnas numéricas
numeric_columns <- uoc_df %>% 
  select(where(is.numeric)) %>% 
  select(-Person.ID, -ID)  # Excluimos identificadores únicos

# 3. Creamos una lista de gráficos de boxplot para cada métrica numérica
boxplots <- lapply(names(numeric_columns), function(col) {
  ggplot(uoc_df, aes(y = .data[[col]])) +
    geom_boxplot(fill = "steelblue", color = "black", outlier.color = "red") +
    theme_minimal() +
    labs(title = col, y = NULL) +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"))
})

# 4.Organizamos y mostramos los gráficos en una cuadrícula
boxplots_grid <- grid.arrange(grobs = boxplots, ncol = 3)

# 5.Guardamos el boxplot en el directorio figuras predefinido
ggsave(figura_guardada, plot = boxplots_grid, width = 10, height = 6, dpi = 300)
```
 

Se observan valores atípicos en las dos variables numericas siguientes:  

1. **Variable "Age"**     
   - Se observa un valor atípico extremadamente alto (cercano a 1000).  
   - Esto sugiere un error en los datos, posiblemente un registro incorrecto, una unidad mal ingresada o un valor centinela.  
   - Debería revisarse y corregirse como se indica en el enunciado.

2. **Variable "HR" (Heart Rate - Frecuencia Cardíaca)**     
   - Se observan varios valores atípicos por encima de 85.  
   - Conviene analizar estos valores para ver si corresponden a momentos específicos (ej. actividad física) o si hay errores.

Por otro lado el resto de variables numéricas ("SH", "SQ", "Stress", "PHY", "Steps", "BPsyst", "BPdias"):     
   - No presentan valores atípicos extremos.  
   - La dispersión parece razonable para cada variable.  
   - Se observa una distribución compacta en algunas variables como "Stress" y "SH", lo que indica poca variabilidad entre los datos.

### **4.2.1. Manejo de valores atípicos**

Para la **variable "HR"**, una frecuencia cardíaca en reposo superior a 85 es habitual en términos médicos [HR en reposo](https://www.mayoclinic.org/es/healthy-lifestyle/fitness/expert-answers/heart-rate/faq-20057979), por lo que no consideramos estos registros como valores atípicos.

Para **la variable "Age"**, se observan valores centinela como el `999`, que indica "edad desconocida". Estos valores pueden distorsionar los análisis, ya que son excesivamente altos en comparación con el rango normal de edades.

 
```{r, Outliers_Age}
# Calcular el rango intercuartílico (IQR) para Age
Q1 <- quantile(uoc_df$Age, 0.25, na.rm = TRUE)
Q3 <- quantile(uoc_df$Age, 0.75, na.rm = TRUE)
IQR_value <- Q3 - Q1

# Definir límites para outliers
lower_bound <- Q1 - 1.5 * IQR_value
upper_bound <- Q3 + 1.5 * IQR_value

# Filtrar solo los registros con valores atípicos en Age
outliers_age <- uoc_df %>%
  filter(Age < lower_bound | Age > upper_bound)

# Mostrar los registros con valores atípicos en Age
outliers_age %>% 
          kable(caption = "Valores atípicos para la variable Age:", "html") %>% 
          kable_styling(font_size = 12, full_width = TRUE)
```
 
Para corregir esto, se reemplaza `999` por `NA`, el estándar en R para datos faltantes, lo que permite que funciones estadísticas y modelos se ejecuten correctamente sin ser afectados por valores irreales.

```{r, Outliers_Age_to_NA}
# 1. Sustituimos el valor 999 por NA en la columna Age
uoc_df <- uoc_df %>%
  mutate(Age = ifelse(Age == 999, NA, Age))

# 2. Verificamos los cambios
sum(uoc_df$Age == 999)
```

\newpage

# **5 Imputación**

Realizad la imputación de las variables que tengan `NAs`, usando el método de imputación basado en los k vecinos más cercanos (k=3). Para la imputación, sólo utilizad las variables numéricas (excepto ID). Al terminar la imputación, mostrad en una tabla los valores imputados.

```{r, ImputacionKNN}
# 1. Seleccionamos solo las variables numéricas (excepto ID)
numeric_vars <- uoc_df[sapply(uoc_df, is.numeric)]
numeric_vars <- numeric_vars[, !names(numeric_vars) %in% c("Person.ID", "ID")]

# 2. Realizamos la imputación KNN con k = 3
imputed_data <- kNN(numeric_vars, k = 3)

# 3. Identificamos los valores imputados
imputed_values <- imputed_data[, grep("imp", colnames(imputed_data))]
colnames(imputed_values) <- gsub("imp_", "", colnames(imputed_values))

# 4. Filtramos solo las filas con valores imputados
imputed_rows <- which(rowSums(imputed_values) > 0)
imputed_table <- imputed_data[imputed_rows, names(numeric_vars)]

# 5. Mostramos la tabla con los valores imputados
imputed_table %>% 
          kable(caption = "Valores imputados en la variable Age:", "html") %>% 
          kable_styling(font_size = 12, full_width = TRUE)
```
 

La tabla anterior contiene los valores imputados para las variables, especialmente la columna `Age`, reemplazando los `NA` en el conjunto de datos original. Estos valores se calcularon usando el método KNN con `k=3`.

```{r, include=FALSE}
# Añadir los valores imputados al dataframe original, solo en las columnas numéricas
uoc_df_imputed <- uoc_df  # Crear una copia del dataframe original

# Seleccionar los valores imputados para la columna 'Age' (de la tabla 'imputed_table')
imputed_age <- imputed_table$Age

# Reemplazar los valores NA en la columna 'Age' de uoc_df_imputed con los valores imputados
uoc_df_imputed$Age[is.na(uoc_df_imputed$Age)] <- imputed_age
```

\newpage

# **6 Correlaciones**

## **6.1 Matriz de correlaciones**

Calculad las correlaciones entre las variables numéricas y mostrad una matriz con el resultado. Interpretad el resultado.

Para calcular la matriz de correlaciones entre las variables numéricas en uoc_df_imputed, podemos usar la función `cor()`, asegurándonos de seleccionar solo las columnas numéricas.

```{r, CorrMatrix, fig.height=6, fig.width=9}
# Definir el nombre del archivo de salida
figura_guardada <- file.path(fig_loc, "Matriz_de_Correlacion.png")

# Seleccionar solo las columnas numéricas, excluyendo identificadores
numeric_vars <- uoc_df_imputed[sapply(uoc_df_imputed, is.numeric)]
numeric_vars <- numeric_vars[, !names(numeric_vars) %in% c("Person.ID", "ID")]

# Calcular la matriz de correlaciones con eliminación de valores NA
cor_matrix <- cor(numeric_vars, use = "pairwise.complete.obs")

# Dibujar la matriz de correlaciones con valores numéricos
gg_corr <- ggcorrplot(cor_matrix, type = "lower", lab = TRUE, lab_size = 4, 
                      colors = c("blue", "white", "red"), # Escala de colores
                      tl.col = "black", tl.srt = 45)
gg_corr

# Guardar la figura en el directorio especificado
ggsave(figura_guardada, plot = gg_corr, width = 10, height = 6, dpi = 300)
```
 
### **6.1.1. Interpretación de la matriz de correlación**
#### **Correlaciones positivas**:
1. **Edad (Age) y Calidad de Sueño (SH)**: Correlación de **0.34** (positiva moderada). A medida que aumenta la edad, también tiende a mejorar la calidad del sueño.
2. **Edad (Age) y Calidad de Sueño (SQ)**: Correlación de **0.48** (positiva moderada). A medida que aumenta la edad, mejora la calidad del sueño.
3. **Edad (Age) y Actividad Física (PHY)**: Correlación de **0.17** (positiva débil). A medida que aumenta la edad, la actividad física muestra un leve aumento.
4. **Edad (Age) y Presión Arterial Sistólica (BPsyst)**: Correlación de **0.57** (positiva moderada). A medida que las personas envejecen, tienden a tener presiones arteriales sistólicas más altas.
5. **Edad (Age) y Presión Arterial Diastólica (BPdias)**: Correlación de **0.56** (positiva moderada). A medida que las personas envejecen, tienden a tener presiones arteriales diastólicas más altas.
6. **Actividad Física (PHY) y Pasos al día (Steps)**: Correlación de **0.77** (positiva alta). A medida que las personas realizan más actividad física, también tienden a dar más pasos.
7. **Frecuencia Cardíaca (HR) y Estrés (Stress)**: Correlación de **0.67** (positiva moderada-alta). A medida que aumenta el estrés, también aumenta la frecuencia cardíaca.
8. **Presión Arterial Sistólica (BPsyst) y Presión Arterial Diastólica (BPdias)**: Correlación de **0.97** (positiva muy alta). La presión arterial sistólica y diastólica están fuertemente relacionadas.
9. **Presión Arterial Diastólica (BPdias) y Pasos al día (Steps)**: Correlación de **0.24** (positiva débil). A medida que aumentan los pasos, se observa un leve aumento en la presión arterial diastólica.

#### **Correlaciones negativas**:
1. **Estrés (Stress) y Calidad de Sueño (SH)**: Correlación de **-0.81** (negativa fuerte). A mayor estrés, peor calidad del sueño.
2. **Estrés (Stress) y Calidad de Sueño (SQ)**: Correlación de **-0.90** (negativa muy fuerte). A mayor estrés, peor calidad del sueño.
3. **Estrés (Stress) y Frecuencia Cardíaca (HR)**: Correlación de **-0.52** (negativa moderada). A medida que aumenta el estrés, la frecuencia cardíaca disminuye.
4. **Frecuencia Cardíaca (HR) y Calidad de Sueño (SH)**: Correlación de **-0.52** (negativa moderada). A mayor frecuencia cardíaca, peor calidad del sueño.
5. **Frecuencia Cardíaca (HR) y Calidad de Sueño (SQ)**: Correlación de **-0.66** (negativa fuerte). A mayor frecuencia cardíaca, peor calidad del sueño.
6. **Actividad Física (PHY) y Estrés (Stress)**: Correlación de **-0.03** (negativa muy débil). No hay una relación significativa entre la actividad física y el estrés.

## **6.2 Cálculo de correlaciones**

Implementad una función propia que calcule la correlación de Pearson entre dos variables (sin usar librerías de R que lo calculen). Validad que la implementación es correcta comparando el resultado con la función cor de R.

 
```{r, PearsonvsCor}
# 1. Creamos la función para calcular la correlación de Pearson manualmente
pearson_cor <- function(x, y) {
  # 1.1. Comprobamos que ambas variables tienen la misma longitud
  if (length(x) != length(y)) {
    stop("Las variables deben tener la misma longitud")
  }
  
  # 1.2. Eliminamos valores NA
  valid_idx <- complete.cases(x, y)
  x <- x[valid_idx]
  y <- y[valid_idx]
  
  # 1.3. Calculamos medias
  mean_x <- mean(x)
  mean_y <- mean(y)
  
  # 1.4. Calculamos numerador y denominador
  num <- sum((x - mean_x) * (y - mean_y))
  den <- sqrt(sum((x - mean_x)^2) * sum((y - mean_y)^2))
  
  # 1.5. Retorna el coeficiente de correlación
  return(num / den)
}

# 2. Validación con la función cor()
x <- uoc_df_imputed$BPsyst
y <- uoc_df_imputed$BPdias

cor_manual <- pearson_cor(x, y)
cor_builtin <- cor(x, y, use = "pairwise.complete.obs")

# 3. Comparamos los resultados
print(paste("Correlación manual:", cor_manual))
print(paste("Correlación con cor():", cor_builtin))
```
 

Con esta comparación se verifica que la correlación de Pearson calculada manualmente es correcta, ya que el valor obtenido a través de la función `pearson_cor` coincide con el valor generado por la función `cor()` de R.

\newpage

# **7 Análisis descriptivo y visual**

A continuación, realizaremos un análisis descriptivo de algunas variables de interés del conjunto de datos. Seguid las indicaciones de los siguientes subapartados.

## **7.1 Tabla resumen de tendencia central y variabilidad de HR según SD (Sleep Disorder)**

Mostrad en una tabla los datos de tendencia central (media) y dispersión (desviación estándar) de las variables SH, SQ, HR y Stress, agregadas según SD (Sleep Disorder). Para poder desarrollar este apartado, podéis usar funciones de la librería dplyr (summarise, group_by, reframe) y kable (para mostrar la tabla).

 

```{r, summary_table_HR}
# Definir el nombre del archivo de salida
summary_table = uoc_df_imputed %>%
                  group_by(SD) %>%
                  summarise(
                    SH_mean = mean(SH, na.rm = TRUE),
                    SH_sd = sd(SH, na.rm = TRUE),
                    SQ_mean = mean(SQ, na.rm = TRUE),
                    SQ_sd = sd(SQ, na.rm = TRUE),
                    HR_mean = mean(HR, na.rm = TRUE),
                    HR_sd = sd(HR, na.rm = TRUE),
                    Stress_mean = mean(Stress, na.rm = TRUE),
                    Stress_sd = sd(Stress, na.rm = TRUE)
  )

summary_table %>% 
          kable(caption = "Tabla resumen de tendencia central y variabilidad de HR según SD:", "html") %>% 
          kable_styling(font_size = 12, full_width = TRUE)
```

## **7.2 Gráfico de medias según HR y Occupation**

A continuación, realizad un gráfico de líneas que muestre el valor de la media de HR según Occupation y SD. Para organizar la información, mostrad en el eje X el tipo de SD y cada línea del gráfico que corresponda a un empleo diferente, usando colores diferentes por cada empleo. Ordenad las categorías en el eje X para mejor claridad. Podéis utilizar la función ggplot (de la librería ggplot2)

 

```{r, LinePlot_HR, fig.height=6, fig.width=9}
figura_guardada <- file.path(fig_loc, "HR segun Ocupacion y SD.png")

HR_OvsSD = uoc_df_imputed %>%
            group_by(SD, Occupation) %>%
            summarise(HR_mean = mean(HR, na.rm = TRUE)) %>%
            ggplot(aes(x = SD, y = HR_mean, color = Occupation, group = Occupation)) +
            geom_line() +
            geom_point() +
            scale_x_discrete(limits = c("None", "Sleep Apnea", "Insomnia")) + 
            labs(title = "Media de HR según Ocupación y Sleep Disorder",
                 x = "Tipo de Sleep Disorder",
                 y = "Media de HR") +
            theme_minimal() +
            theme(legend.title = element_blank())

HR_OvsSD

# Guardar la figura en el directorio especificado
ggsave(figura_guardada, plot = HR_OvsSD, width = 10, height = 6, dpi = 300)
```
 

# **8 Archivo final**

Una vez realizado el preprocesamiento sobre el archivo, guardad el resultado de los datos en un archivo csv
llamado sleephealth_processed.csv.

```{r, output}
write.csv2(uoc_df_imputed, file = paste0(Output_loc, "/sleephealth_processed.csv"), row.names = FALSE)
```